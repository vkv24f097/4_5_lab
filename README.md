# FN-informatics-04-trees
Данная работа направлена на разработку деревьев поиска Binary Search Tree (BST)

## Задание 1
Реализация класса бинарного дерева поиска.
Методы класса:
```cpp
template <class T>
class Tree {
public:
  struct Node {
    Node* Left;
    Node* Right;
    T Value;
  };

  BinarySearchTree();
~BinarySearchTree();

  void Add(const T&);
  Node* Find(const T&);
  void Remove(Node*);
};
```
## Выполнение:<br>
### Вспомогательные методы:<br>
`DestroyTree` - рекурсивно удаляет все узлы дерева (пост-порядок обхода)<br>
`AddNode` - рекурсивно добавляет новый узел в правильное место:<br>
Если значение меньше текущего узла, то идем влево<br>
Если больше или равно, то идем вправо<br>
`FindNode` - рекурсивный поиск узла по значению:<br>
- Возвращает `nullptr`, если значение не найдено<br>
- Использует свойства `BST` для эффективного поиска<br>
`FindMin` - находит узел с минимальным значением в поддереве<br>
`DeleteNode` - рекурсивно удаляет узел с заданным значением, обрабатывая три случая:
   1. У узла нет потомков (просто удаляем)<br>
   2. У узла один потомок (заменяем удаляемый узел на потомка)<br>
   3. У узла два потомка (находим минимальный в правом поддереве, заменяем значения и рекурсивно удаляем минимальный)<br>
   
### Узел дерева (Node)
```
struct Node {
    Node* left;    // Указатель на левое поддерево
    Node* right;   // Указатель на правое поддерево
    T value;       // Значение узла
    
    Node(const T& val) : left(nullptr), right(nullptr), value(val) {}
};
```
Каждый узел содержит указатели на левого и правого потомка, значение типа T (шаблонный параметр) и конструктор, инициализирующий значение и устанавливающий указатели в `nullptr`

### Основные методы класса: 
1. Конструктор и деструктор
```
BinarySearchTree() : root(nullptr) {}  // Инициализирует пустое дерево
~BinarySearchTree() {
    DestroyTree(root);  // Рекурсивно удаляет все узлы
}
```
2. Добавление элемента (Add)
```
void Add(const T& value) {
  if (root == nullptr) {
        root = new Node(value);  // Если дерево пустое, создаем корень
    } else {
        AddNode(root, value);    // Иначе добавляем в нужное место
    }
}
```
3. Поиск элемента (Find)
```
Node* Find(const T& value) {
return FindNode(root, value);  // Рекурсивный поиск
}
```
4. Удаление элемента (Delete)
```
void Delete(Node* node) {
    if (node == nullptr) return;
    root = DeleteNode(root, node->value);  // Удаление по значению
}
```
В среднем алгоритм работает за O(log n) времени

## Задание 2
Реализовать функцию обхода с выводом бинарного дерева поиска
  5 % 4 = 1. Метод - Прямой обход (preorder) <br>

Прямой обход - это один из стандартных способов обхода бинарного дерева, который реализован в функции `preorder()`<br>
### Алгоритм прямого обхода:
1. Посетить корень (обработать текущий узел)
2. Рекурсивно обойти левое поддерево
3. Рекурсивно обойти правое поддерево
Конкретная реализация из кода:
```
void preorder(Node* root) {
    if (root != nullptr) {
        // 1. Посетить корень
        cout << root->data << " ";
        
        // 2. Обойти левое поддерево
        preorder(root->left);
        
        // 3. Обойти правое поддерево
        preorder(root->right);
    }
}
```
Для введенных значений (5, 3, 7, 2, 4,6, 8):
Последовательность вызовов будет следующей:

`preorder(5)` -> 5 <br>
`preorder(3)` (левое поддерево) -> 3 <br>
`preorder(2)` -> 2<br>
`preorder(nullptr)` - пропускается<br>
`preorder(nullptr)` - пропускается<br>
`preorder(4)`->4<br>
`preorder(nullptr)` - пропускается<br>
`preorder(nullptr)` - пропускается<br>
`preorder(7)` (правое поддерево) -> 7<br>
`preorder(6)` -> 6<br>
`preorder(nullptr)` - пропускается<br>
`preorder(nullptr)` - пропускается<br>
`preorder(8)` - > 8<br>
`preorder(nullptr)` - пропускается<br>
`preorder(nullptr)` - пропускается<br>

`Результат выполнения:` 5 3 2 4 7 6 8

## Задание 3
Реализуйте кастомную функцию согласно вашему варианту: <br>
5 % 8 = 5<br>
Задача:  Поиск медианы в BST<br>
**Условие**: Напишите метод `T median()`, находящий медиану (средний элемент) для BST с нечётным числом узлов.  <br>
**Оптимизация**: Используйте метод двух указателей без полного обхода.<br>
### Выполнение:
Структура классов
1. Класс `BSTNode`
```
template <typename T>
class BSTNode {
public:
    T data;             // Значение узла
    BSTNode<T>* left;   // Указатель на левое поддерево
    BSTNode<T>* right;  // Указатель на правое поддерево
    
    BSTNode(T val) : data(val), left(nullptr), right(nullptr) {}
};
```
Шаблонный класс узла дерева, хранящий данные и указатели на потомков.
2. Класс `BST`
```
template <typename T>
class BST {
private:
    BSTNode<T>* root;  // Корень дерева
    int size;         // Количество элементов в дереве
    // ... методы ...

};
```
### Ключевые методы
1. Вставка `insert`<br>
  - Итеративная (не рекурсивная) реализация вставки<br>
  - Сохраняет свойство `BST` (меньшие значения слева, большие справа)<br>
  - Увеличивает счетчик элементов (size)<br>

2. Поиск медианы `median`<br>
   - Проверяет, что дерево не пустое и имеет нечетное количество элементов<br>
   - Вычисляет позицию медианы (середина отсортированного списка)<br>
   - Использует вспомогательную функцию `findMedian`<br>

3. Вспомогательная функция `findMedian` - рекурсивный симметричный обход `in-order traversal`, который:
   - Сначала обходит левое поддерево<br>
   - Затем обрабатывает текущий узел (увеличивает счетчик)<br>
   - Если счетчик достиг целевой позиции - возвращает текущий узел, иначе обходит правое поддерево<br>



# Финальный проект
5 = ваш номер в ЭУ<br>
Ваш вариант = 5 % 30 = 5 <br>

##  **Задание A (вариант 5): “Поисковый движок миниатюра”**

###  Задача:

Реализуйте консольное приложение, имитирующее простой поисковый движок. На вход подаются текстовые документы (строки или файлы), после чего пользователь может выполнять текстовые поисковые запросы.

###  Базовые требования:

- Использовать `std::map` или `std::set` для хранения индекса слов.
    
- Сканировать текст и хранить, в каких документах встречается каждое слово.
- - Поддержать команду: `FIND word` — найти документы, где встречается слово.
    
- Обязательно реализовать **один из алгоритмов сортировки вручную** (quick/merge/heap) для сортировки результатов по частоте.
    
- Использовать `unordered_map` или свою хеш-таблицу для ускорения доступа к словарю.
    

###  Расширения:

- Добавить булевы запросы (`AND`, `OR`, `NOT`)
    
- Поддержка фразового поиска ("две рядом стоящие строки")
    
- Индивидуализация: у каждого студента — разные наборы документов (задать ID и URL текстов или сгенерировать случайные).
    
# Анализ кода поисковой системы по документам

Этот код реализует простую поисковую систему, которая индексирует документы по отдельным словам и парам слов, а затем позволяет выполнять поиск по этим индексам.

## Основные компоненты системы

### 1. Структуры данных
- `WordInfo` - хранит информацию о слове в конкретном документе (`ID` документа и частоту встречаемости)
- `SearchResult` - хранит результаты поиска (`ID` документа и суммарную частоту)

### 2. Основные функции
- `to_lower()` - преобразует строку в нижний регистр
- `clean_word()` - очищает слово от знаков препинания
- `merge()` и `merge_sort()` - реализуют сортировку слиянием для результатов поиска

### 3. Хранилища данных
- `index` - хеш-таблица (unordered_map), которая для каждого слова хранит список документов, где оно встречается, с частотами
- `pair_index` - аналогичная хеш-таблица для пар слов

## Работа программы

### 1. Ввод документов
Программа запрашивает количество документов и их содержимое. Для каждого документа:
1. Текст разбивается на слова
2. Слова очищаются и приводятся к нижнему регистру
3. Для каждого слова обновляется частота в текущем документе
4. Слова добавляются в общий индекс `index`
5. Пары соседних слов добавляются в индекс пар `pair_index`

### 2. Обработка запросов
Программа поддерживает три команды:
1. `FIND __`  - поиск отдельного слова
   - Слово очищается и приводится к нижнему регистру
   - Из индекса извлекаются все документы, содержащие это слово
   - Результаты сортируются по частоте встречаемости (по убыванию)
   - Выводится список документов с частотами

2. `FIND_PAIR __ __`  - поиск пары слов
   - Оба слова очищаются и приводятся к нижнему регистру
   - Из индекса пар извлекаются документы, содержащие эту пару
   - Результаты сортируются по частоте
   - Выводится список документов

3. `EXIT` - завершение программы

### 3. Сортировка результатов
Для сортировки результатов используется алгоритм сортировки слиянием `merge sort`, который:
1. Рекурсивно разделяет массив на две части
2. Сортирует каждую часть
3. Объединяет отсортированные части в один массив

## Пример работы
1. Пользователь вводит 2 документа:
   - "Hello world"
   - "World of engine"

2. При поиске `FIND world` система найдет:
   - Документ 1: 1 раз
   - Документ 2: 1 раз

3. При поиске `FIND_PAIR hello world` система найдет только документ 1

## Особенности реализации
1. Регистронезависимый поиск (все слова переводятся в нижний регистр автоматически)
2. Игнорирование знаков препинания при поиске
3. Сортировка результатов по релевантности (частоте встречаемости)
4. Поддержка поиска как отдельных слов, так и пар слов
5. Использование хеш-таблиц для эффективного поиска
6. Проблемы с булевыми запросами

# Индивидуальные условия


###  **Задание A: Поисковый движок**
`Для индивидуального условия был сделан отдельный код` <br>
Уникальная конфигурация: индексировать пары слов ("co-occurrence")
# Уникальная конфигурация: индексирование пар слов (co-occurrence)

В данной программе реализована особая функциональность - индексация пар соседних слов (co-occurrence), что позволяет выполнять поиск не только отдельных слов, но и их сочетаний. Вот как это работает:

## Механизм индексации пар слов

1. **Генерация пар**:
   - При обработке каждого документа программа сохраняет все слова в вектор `words`
   - Затем проходит по этому вектору и формирует пары из каждого слова с последующим:
     ```
     for (size_t j = 1; j < words.size(); j++) {
         string pair = words[j - 1] + " " + words[j];
         pair_index[pair].push_back({ i, 1 });
     }
     ```
   - Например, для текста "hello world program" будут созданы пары:
     - "hello world"
     - "world program"

2. **Хранение пар**:
   - Пары хранятся в отдельной хеш-таблице `pair_index`:
     ```
     unordered_map<string, vector<WordInfo>> pair_index;
     ```
   - Ключом является строка из двух слов, разделенных пробелом
   - Значение - список документов, где встречается эта пара

3. **Особенности реализации**:
   - Учитывается только непосредственное соседство слов (биграммы)
   - Порядок слов в паре важен: "gold apple" ≠ "apple gold"
   - Пары также очищаются от знаков препинания и приводятся к нижнему регистру

## Поиск по парам слов

Для поиска пар используется команда: `FIND_PAIR __ __`

Алгоритм поиска:
1. Введенные слова очищаются и приводятся к нижнему регистру
2. Формируется строка пары (слово1 + пробел + слово2)
3. Поиск в хеш-таблице `pair_index`:
   ```
   if (pair_index.find(pair) == pair_index.end()) {
       cout << "Pair not found in any document." << endl;
       continue;
   }
   ```
4. Результаты сортируются по частоте встречаемости (хотя для пар частота всегда 1)
5. Выводится список документов, содержащих данную пару

## Пример работы

Для документов:
1. "hello gold test"
2. "gold of programming"
3. "test hello gold"

Будут проиндексированы пары:
- Документ 1: "hello gold", "gold test"
- Документ 2: "gold of", "of programming"
- Документ 3: "test hello", "hello gold"

При поиске "FIND_PAIR hello gold" программа найдет:
- Документ 1
- Документ 3

## Преимущества такого подхода

1. Позволяет искать устойчивые словосочетания
2. Учитывает семантическую связь между словами
3. Может использоваться для:
   - Поиска терминологических сочетаний
   - Анализа коллокаций (устойчивых сочетаний слов)
   - Выявления часто встречающихся пар слов

## Особенности реализации
1. Учитывается только непосредственное соседство (без учета расстояния между словами)
2. Регистр и знаки препинания игнорируются, что повышает надежность поиска

